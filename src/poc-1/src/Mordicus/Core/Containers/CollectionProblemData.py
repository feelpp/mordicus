# -*- coding: utf-8 -*-

import numpy as np
import pickle
from scipy import sparse
from Mordicus.Core.Containers import ProblemData
from Mordicus.Core.Containers import Solution


class CollectionProblemData(object):
    """
    Class containing a set of collection of problemData
    
    Attributes
    ----------
    problemDatas : dict
        dictionary with problem tags (str) as keys and problemDatas (ProblemData) as values
    reducedOrderBases : dict
        dictionary with solutionNames (str) as keys and reducedOrderBases (np.ndarray of size (numberOfModes, numberOfDOFs)) as values
    snapshotCorrelationOperators : dict
        dictionary with solutionNames (str) as keys and matrices (scipy.sparse.csr) as values
    operatorCompressionData : custom data structure
        data structure generated by the operator compression step, needed for the online stage
    """

    def __init__(self):

        self.problemDatas = {}
        self.reducedOrderBases = {}
        self.snapshotCorrelationOperators = {}
        self.operatorCompressionData = None
        

    def AddReducedOrderBasis(self, solutionName, reducedOrderBasis):
        """
        Adds a reducedOrderBasis corresponding to solution solutionName
        
        Parameters
        ----------
        solutionName : str
            name of the solution for which reducedOrderBasis is a reduced order basis
        reducedOrderBasis : np.ndarray
            of size (numberOfModes, numberOfDOFs)
        """
        assert isinstance(solutionName, str), "solutionName must be of type string"
        assert (
            isinstance(reducedOrderBasis, np.ndarray)
            and len(reducedOrderBasis.shape) == 2
        ), "reducedOrderBasis must be a 2D np.ndarray"

        # assert that all solutions have same size and that the secnd dimension of reducedOrderBasis has this dimension
        listNumberOfDofs = [
            problemData1.solutions[solutionName].numberOfDOFs
            for _, problemData1 in self.problemDatas.items()
        ]
        assert listNumberOfDofs.count(listNumberOfDofs[0]) == len(listNumberOfDofs)
        assert (
            reducedOrderBasis.shape[1] == listNumberOfDofs[0]
        ), "inconsistence dimension between reducedOrderBasis and solutions from problemDatas"

        self.reducedOrderBases[solutionName] = reducedOrderBasis

    def GetReducedOrderBasis(self, solutionName):
        """
        Get a precomputed reducedOrderBases for solution solutionName
        
        Parameters
        ----------
        solutionName : str
            name of the solution for which the reducedOrderBases is retrieved
            
        Returns
        -------
        np.ndarray
            of size (numberOfModes, numberOfDOFs)
        """
        assert isinstance(solutionName, str), "name must be of type string"
        if solutionName not in self.reducedOrderBases:
            raise (
                "You must compute a reducedOrderBasis for solution named "
                + solutionName
                + " before trying to retrieve it"
            )  # pragma: no cover

        return self.reducedOrderBases[solutionName]

    def GetReducedOrderBasisNumberOfModes(self, solutionName):
        """
        Get the number of modes of a precomputed reducedOrderBases for solution solutionName
        
        Parameters
        ----------
        solutionName : str
            name of the solution for which the reducedOrderBases is retrieved
            
        Returns
        -------
        int
            numberOfModes
        """
        assert isinstance(solutionName, str), "name must be of type string"
        if solutionName not in self.reducedOrderBases:
            raise (
                "You must compute a reducedOrderBasis for solution named "
                + solutionName
                + " before trying to retrieve it"
            )  # pragma: no cover

        return self.GetReducedOrderBasis(solutionName).shape[0]

    def AddProblemData(self, problemData):
        """
        Adds a problemData to the structure
        
        Parameters
        ----------
        tag : str
            tag given to the problemData
        problemData : ProblemData
            to add to the problemDatas dictionary
        """
        assert isinstance(
            problemData, ProblemData.ProblemData
        ), "wrong type for problemData"
        if problemData.GetProblemDataName() in self.problemDatas:
            print(
                "ProblemData "
                + problemData.GetProblemDataName()
                + " already in CollectionProblemData. Replacing it anyways."
            )  # pragma: no cover

        self.problemDatas[problemData.GetProblemDataName()] = problemData
        return

    def GetProblemData(self, tag):
        """
        Parameters
        ----------
        tag : str
            tag of the problemData to retrieve
            
        Returns
        -------
        ProblemData
            retrieved problemData
        """
        assert isinstance(tag, str), "name must be of type string"
        if tag not in self.problemDatas:
            raise (
                "You must add a problemData with tag "
                + tag
                + " before trying to retrieve it"
            )  # pragma: no cover

        return self.problemDatas[tag]


    def GetNumberOfProblemDatas(self):
        """
        Returns
        -------
        int
            the number of problemDatas
        """
        return len(self.problemDatas.keys())


    def GetSolutionsNumberOfDofs(self, solutionName):
        """
        Assert that the solutions of all problemDatas have the same numberOfDOFs
        and return this size
        
        Returns
        -------
        int
            numberOfDOFs of solutions solutionName
        """
        listNumberOfDofs = [
            problemData.solutions[solutionName].GetNumberOfDofs()
            for _, problemData in self.GetProblemDatas().items()
        ]
        assert listNumberOfDofs.count(listNumberOfDofs[0]) == len(listNumberOfDofs)
        return listNumberOfDofs[0]

    def GetParameterDimension(self):
        """
        Assert that the parameters of all problemDatas have the same parameterDimension
        and return this size
        
        Returns
        -------
        int
            parameterDimension of problemDatas
        """
        listParameterDimension = [
            problemData.GetParameterDimension()
            for _, problemData in self.GetProblemDatas().items()
        ]
        assert listParameterDimension.count(listParameterDimension[0]) == len(
            listParameterDimension
        )
        return listParameterDimension[0]

    def GetProblemDatas(self):
        """
        Returns
        -------
        collections.OrderedDict()
            problemDatas of the collectionProblemData
        """
        return self.problemDatas

    def GetProblemDatasTags(self):
        """
        Returns
        -------
        list
            list containing the tags of the available problemDatas
        """
        return list(self.GetProblemDatas().keys())

    def GetGlobalNumberOfSnapshots(self, solutionName):
        """
        Iterates over problemDatas to return the complete number of snpashots for solutions of name "solutionName"
        
        Parameters
        ----------
        solutionName : str
            name of the solutions for which we want to compute the total number of snapshots
            
        Returns
        -------
        int
            number of snpashots for solutions of name "solutionName"
        """
        number = 0
        for _, problemData in self.problemDatas.items():
            number += problemData.solutions[solutionName].GetNumberOfSnapshots()
        return number

    def GetSolutionsNumberOfComponents(self, solutionName):
        """
        Asserts that the solutions of name "solutionName" in all problemDatas have same nbeOfComponents
        and return this size
        
        Parameters
        ----------
        solutionName : str
            name of the solutions for which we want to return the nbeOfComponents
            
        Returns
        -------
        int
            nbeOfComponents of solutions of name "solutionName"
        """
        nbeOfComponents = [
            problemData.solutions[solutionName].GetNbeOfComponents()
            for _, problemData in self.GetProblemDatas().items()
        ]
        assert nbeOfComponents.count(nbeOfComponents[0]) == len(nbeOfComponents)

        return nbeOfComponents[0]

    def SnapshotsIterator(self, solutionName):
        """
        Constructs an iterator over snapshots of solutions of name "solutionName" in all problemDatas.
        
        Parameters
        ----------
        solutionName : str
            name of the solutions on which we want to iterate over snapshots
        
        Returns
        -------
        iterator
            an iterator over snapshots of solutions of name "solutionName" in all problemDatas
        """
        this = self

        class iterator:
            def __init__(self, solutionName):
                self.solutionName = solutionName
                self.problemDatas = this.problemDatas

            def __iter__(self):
                for _, problemData in self.problemDatas.items():
                    for _, snapshot in problemData.solutions[
                        self.solutionName
                    ].snapshots.items():
                        yield snapshot

        res = iterator(solutionName)
        return res

    def SetSnapshotCorrelationOperator(self, solutionName, snapshotCorrelationOperator):
        """
        Sets the snapshotCorrelationOperator for solution of name solutionName
        
        Parameters
        ----------
        solutionName : str
        snapshotCorrelationOperator : scipy.sparse.csr
        """
        self.snapshotCorrelationOperators[solutionName] = snapshotCorrelationOperator

    def GetSnapshotCorrelationOperator(self, solutionName):
        """
        Get the snapshotCorrelationOperator for solution of name solutionName. If the corresponding snapshotCorrelationOperator has not been computed, the function returns the identity matrix of correct size.
        
        Parameters
        ----------
        solutionName : str
            name of the solutions for which we want to return the l2ScalarProducMatrix
            
        Returns
        -------
        scipy.sparse.csr
            l2ScalarProducMatrix of solutions of name "solutionName"
        """
        if solutionName in self.snapshotCorrelationOperators:
            return self.snapshotCorrelationOperators[solutionName]
        else:
            print("snapshotCorrelationOperator not set, returning an identify matrix")
            numberOfDOFs = self.GetSolutionsNumberOfDofs(solutionName)
            return sparse.eye(numberOfDOFs)
        

    def SetOperatorCompressionData(self, operatorCompressionData):
        """
        Sets the OperatorCompressionData
        
        Parameters
        ----------
        operatorCompressionData : ustom data structure
        """
        self.operatorCompressionData = operatorCompressionData

    def GetOperatorCompressionData(self):
        """
        Get the OperatorCompressionData
            
        Returns
        -------
        operatorCompressionData
            ustom data structure
        """
        return self.operatorCompressionData


    def Save(self, fileName):
        """
        Saves the data structure on disk

        Parameters
        ----------
        fileName : str
            name of the file to write on disk
        """
        import pickle

        print("WARNING: snapshots and large data in loadings are supress from current data structure before save. If you need them later, you will have to read them again")
        
        for pd in self.problemDatas.values():
            pd.DeleteHeavyData()

        output = open(fileName+".pkl", "wb")
        pickle.dump(self, output)
        output.close()


    def __str__(self):
        res = "CollectionProblemData\n"
        res += "number of problemDatas: " + str(self.GetNumberOfProblemDatas()) + "\n"
        res += "problemDatas: " + str(list(self.problemDatas.keys()))
        return res


def Load(fileName):
    """
    Read the data structure from disk

    Parameters
    ----------
    fileName : str
        name of the file on disk
    """    
    return pickle.load(open(fileName, "rb"))
        
